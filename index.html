<!DOCTYPE html>
<html>

<head>
    <title>Katapult</title>
    <meta charset="utf-8">
    <script src="./libs/paper-full.min.js"></script>
    <script src="./libs/qrcode.js"></script>
    <script src="./libs/qr-scanner.umd.min.js"></script>
    <style>
        html {
            height: 100%;
            padding: 0;
        }
        
        body {
            display: flex;
            flex-flow: column;
            height: 100%;
            margin: 0 10px;
            font-family: sans-serif;
        }
        
        svg {
            display: block;
            width: 100%;
            flex-grow: 1;
        }
        .footer {
            height: 3em;
            font-size: 0.6em;
            overflow: auto;
        }
        #note {
            font-weight: bold;
        }
        #overlay {
            position: absolute;
            top: 10%;
            left: 10%;
            right: 10%;
            bottom: 10%;
            display: none;
            background: white;
            padding: 2%;
        }
        #overlay img {
            position: absolute;
            margin: auto;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        video {
            position: absolute;
            top: 10%;
            left: 10%;
            width: 80%;
            height: 80%;
            display: none;
        }

    </style>
</head>

<body>
    <h2>Katapult konfigurieren</h2>
    <div id="note"></div>
    <p id="controls">
        <label><input type="number" id="dicke" min="2" max="4" value="3.8" style="width:3em" title="Materialstärke">mm</label>
        <input type="range" id="laenge" min=150 max=300 value="210" title="Katapultlänge" />
        <input type="range" id="breite" min=60 max=150 value="95" title="Katapultbreite" />
        <input type="range" id="armLaenge" min=50 max=150 value="95" title="Armlänge" />
        <input type="range" id="achse" min=-20 max=20 value="4" title="Achsenposition" />
        <input type="text" id="name" value="Mein Name" size="15">
        <button id="download" title="SVG-Datei herunterladen">Download</button>
        <button id="qrcode" title="QR-Code anzeigen">QR-Code</button>
        <button id="scan" title="Mit Kamera QR-Code scannen" style="display:none">Scanner</button>        
    </p>
    <svg viewbox="0 0 450 350">

        <!-- put static objects here -->
        
    </svg>
    <div class="footer">
        License of design <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">Creative Commons - Attribution - Non-Commercial</a>. License of source code: MIT License (2023 by Andreas Schuderer).
        Design based on this educational <a href="https://www.thingiverse.com/thing:1403796" target="_blank">Tension Catapult by Thingiverse user mfalk</a> (<a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a>) and its <a href="https://www.thingiverse.com/thing:4050155" target="_blank">no-glue derivative by SimpleAsWar</a> (<a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>).
    </div>
    <div id="overlay"></div>
    <video id="video"></video>
    <script>
        // Generic code here, skip this portion

        const svg = document.querySelector("svg")
        const units = 'mm';
        
        function ensureObj(queryOrObject) {
            if (typeof queryOrObject === 'string' || queryOrObject instanceof String) {
                queryOrObject = document.querySelector(queryOrObject)
            }
            return queryOrObject
        }
        
        function setAttribs(svgObj, attribs) {
            for (const prop in attribs) {
                svgObj.setAttributeNS(null, prop, attribs[prop]);
            }
        }
        
        function resetTransform(svgObj) {
            svgObj = ensureObj(svgObj)
            svgObj.setAttribute('transform', '')
            return svgObj
        }
        
        function appendTransform(svgObj, transformStr) {
            const prevTransform = svgObj.getAttribute('transform') || ''
            svgObj.setAttribute('transform', `${transformStr} ${prevTransform}`)
            return svgObj
        }
        
        function scale(svgObj, scaleX, scaleY, centerX=0, centerY=0, inplace=false) {
            // For mirroring, use a scale factor of -1
            svgObj = ensureObj(svgObj)
            if (!inplace) {
                svgObj = svgObj.cloneNode()
            }
            appendTransform(svgObj, `translate(${centerX}, ${centerY}) scale(${scaleX}, ${scaleY}) translate(${-centerX}, ${-centerY})`)     
            return svgObj
        }

        function rotate(svgObj, angle, centerX=0, centerY=0, inplace=false) {
            svgObj = ensureObj(svgObj)
            if (!inplace) {
                svgObj = svgObj.cloneNode()
            }
            appendTransform(svgObj, `translate(${centerX}, ${centerY}) rotate(${angle}) translate(${-centerX}, ${-centerY})`)
            return svgObj
        }

        function skew(svgObj, skewX, skewY=0, inplace=false) {
            svgObj = ensureObj(svgObj)
            if (!inplace) {
                svgObj = svgObj.cloneNode()
            }
            appendTransform(svgObj, `skew(${skewX}, ${skewY})`)     
            return svgObj
        }
        
        function translate(svgObj, dx, dy, inplace=false) {
            svgObj = ensureObj(svgObj)
            if (!inplace) {
                svgObj = svgObj.cloneNode()
            }
            appendTransform(svgObj, `translate(${dx}, ${dy})`)     
            return svgObj
        }
        
        function mirrorX(svgObj, centerX=0, centerY=0, inplace=false) {
            return scale(svgObj,  -1, 1, centerX, centerY, inplace)
        }
        
        function mirrorY(svgObj, centerX=0, centerY=0, inplace=false) {
            return scale(svgObj,  1, -1, centerX, centerY, inplace)
        }
        
        class PathD {
            // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths
            constructor(startAtX, startAtY) {
                this.d = ''
                if (startAtX !== undefined && startAtY !== undefined) {
                    this.absMove(startAtX, startAtY)
                }
            }

            add(dStr) {
                //console.log(`Adding '${dStr}' to this.d='${this.d}'`)
                this.d += ` ${dStr}`
                return this
            }

            absMove(x, y) { // path segment: move to absolute position
                this.add(`M ${x} ${y}`)
                return this
            }

            move(dx, dy) { // path segment: move to relative position
                this.add(`m ${dx} ${dy}`)
                return this
            }

            halfCircle(dy) { // path segment: half circle to relative position
                this.add(`a ${dy/2} ${dy/2} 0 0 1 0 ${dy}`)
                return this
            }

            line(dx, dy) { // path segment: line to relative position
                this.add(`l ${dx} ${dy}`)
                return this
            }

            hLine(dx) { // path segment: line to relative position at same height
                this.add(`h ${dx}`)
                return this
            }

            vLine(dy) { // path segment: line to relative position in same column
                this.add(`v ${dy}`)
                return this
            }

            close() { // path segment: close path
                this.add(`z`)
                return this
            }
            
            static _ensurePaperReady() {
                let canvas = document.getElementById('booleanCanvas')
                if (canvas) {
                    paper.project.activeLayer.removeChildren()
                }
                else {
                    canvas = document.createElement('canvas')
                    canvas.setAttribute('id', 'booleanCanvas')
                    canvas.setAttribute('style', 'display:none')
                    canvas.setAttribute('resize', 'resize')
                    document.body.appendChild(canvas)
                    paper.setup(canvas)
                }
            }
            
            boolean(other, operation) {   
                PathD._ensurePaperReady()
                const path1 = new paper.Path(this.toString())
                const path2 = new paper.Path(other.toString())

                const result = path2[operation](path1)

                //exportSVG() doc: http://paperjs.org/reference/item/#exportsvg
                const svgPathElement = result.exportSVG()
                const d = svgPathElement.getAttribute('d')
                return (new PathD()).add(d)
            }
            
            // Join and keep outline of both paths, discard inner overlap
            union(other) {
                return this.boolean(other, 'unite')
            }
            // Subtract other path from this path
            difference(other) {
                return other.boolean(this, 'subtract')
            }
            // Only keep path around intersecting area
            intersection(other) {
                return this.boolean(other, 'intersect')
            }
            // Only keep path *other* than intersecting area
            exclude(other) {
                return this.boolean(other, 'exclude')
            }
            // Only keep part of this that is enclosed by other
            divide(other) {
                return this.boolean(other, 'divide')
            }
            
            static fromSvg(svgObj) {
                PathD._ensurePaperReady()
                svgObj = ensureObj(svgObj)
                paper.project.clear()
                paper.project.activeLayer.importSVG(svgObj, {
                    expandShapes: true,  // expand everything to path items
                    insert: true,  // draw the path
                })
                const paths = []
                for (const item of paper.project.activeLayer.children) {
                    let d = ''
                    if (item instanceof paper.Path) {
                        d = item.exportSVG().getAttribute('d')
                    }
                    else {
                        throw Error(`PathD.fromSvg got passed a ${typeof item}: ${item}. Only shapes (paths, circles, rects, ...) are allowed`)
                    }
                    paths.push(PathD.fromString(d))
                    if (paths.length > 1) {
                        console.warn(`PathD.fromSvg got more than one object. All but the first object will be ignored`)
                    }
                }
                return paths[0]
//                const name = svgObj.tagName.toLowerCase()
//                if (name === 'circle') {
//                    const x = Number(svgObj.getAttribute('cx'))
//                    const y = Number(svgObj.getAttribute('cy'))
//                    const r = Number(svgObj.getAttribute('r'))
//                    const obj = paper.Shape.Circle(
//                        new paper.Point(x, y),
//                        r
//                    )
//                    const path = obj.toPath(false).exportSVG()
//                    return PathD.fromString(path.getAttribute('d'))
//                }
            }
            
            static fromString(dStr) {
                const p = new PathD()
                p.d = dStr
                return p
            }

            toString() {
                return this.d.trim()
            }
        }

        class Drawable {
            static idSeq = 0
            static lastParent = null
            static all = []
            static eventsAllowed = true

            constructor(parent = undefined) {
                this.parent = ensureObj(parent) || Drawable.lastParent
                if (!this.parent) throw new Error('no parent group/svg element')
                Drawable.lastParent = this.parent
                this.id = 'obj' + Drawable.idSeq++
                    this.eventListeners = {}
                this.numericProps = []
                Drawable.all.push(this)
            }

            update() {
                throw new Error('update() not implemented')
            }
        
            static update() {
                Drawable.eventsAllowed = false
                for (const elem of Drawable.all) {
                    elem.update()
                }
                Drawable.eventsAllowed = true
            }

            createRootElem(svgElemName, attribs) {
                return this.createElem(svgElemName, attribs, true)
            }

            createElem(svgElemName, attribs, isRoot = false) {
                const elem = document.createElementNS('http://www.w3.org/2000/svg', svgElemName);
                setAttribs(elem, attribs)
                if (isRoot) {
                    this.elem = elem
                    this.parent.appendChild(this.elem)
                }
                return elem
            }

            makeProp(propName, propValue) {
                const privPropName = `_${propName}`
                this[privPropName] = propValue
                if (Number.isFinite(propValue)) {
                    this.numericProps.push(propName)
                }
                Object.defineProperty(this, propName, {
                    get() {
                            return this[privPropName]
                        },
                        set(val) {
                            if (this.numericProps.includes(propName)) {
                                val = Number(val)
                            }
                            this[privPropName] = val
                            if (!Drawable.eventsAllowed) return
                            const listeners = this.eventListeners[propName] || []
                            for (const callback of listeners) {
                                // console.log(`${this}.${propName} changed to ${val}, firing callback ${callback}`)
                                callback()
                            }
                        },
                })
            }
        
            makeTooltip(text) {
                const titleElem = this.createElem('title')
                titleElem.textContent = text
                this.elem.appendChild(titleElem)
                return titleElem
            }

            addCallback(propName, callback) {
                this.eventListeners[propName] = this.eventListeners[propName] || []
                this.eventListeners[propName].push(callback);
            }

            bind(myPropNameOrFunction, controlObj, controlProp = 'value') {
                controlObj = ensureObj(controlObj)
                if (typeof myPropNameOrFunction === 'function' || myPropNameOrFunction instanceof Function) {
                    this.bindFunc(myPropNameOrFunction, controlObj, controlProp)
                } else {
                    const myPropName = myPropNameOrFunction
                    const that = this
                    const callback = function (evt) {
                        const val = controlProp ? controlObj[controlProp] : controlObj.value
                        console.log(`Updating ${that}.${myPropName} to ${val} using ${controlObj}.${controlProp}`)
                        that[myPropName] = val
                        that.update()
                    }
                    this.bindFunc(callback, controlObj, controlProp)
                }
            }

            bindFunc(callback, controlObj, controlProp = 'value') {
                controlObj = ensureObj(controlObj)
                if (controlObj instanceof Drawable) {
                    controlObj.addCallback(controlProp, callback)
                } else {
                    controlObj.addEventListener('input', callback)
                }
                callback()
            }

            toString() {
                return `[${this.constructor.name} ${this.id}]`
            }
        }

        class Group extends Drawable {
            constructor(drawablesToContain, attribs, parent = undefined) {
                super(parent)
                this.elems = drawablesToContain
                this.attribs = attribs
                this.createRootElem('g', attribs)
                for (const prop of attribs) {
                    this.makeProp(prop, attribs[prop])
                }
            }

            update() {
                for (const prop of this.attribs) {
                    this.attrib[prop] = this[prop]
                    this.elem.setAttributeNS(null, prop, this.attribs[prop]);
                }
                for (const sub of this.elems) {
                    sub.update()
                }
            }
        }

        class SvgProxy extends Drawable {
            constructor(queryOrMarkupOrObjs, parent = undefined) {
                if (!queryOrMarkupOrObjs) {
                    throw Error(`queryOrMarkupOrObjs must be provided`)
                }
                const isIterable = typeof queryOrMarkupOrObjs[Symbol.iterator] === 'function'
                let objs = isIterable ? queryOrMarkupOrObjs : [queryOrMarkupOrObjs]
                if (typeof queryOrMarkupOrObjs === 'string' || queryOrMarkupOrObjs instanceof String) {
                    try {
                        objs = document.querySelectorAll(queryOrMarkupOrObjs)
                        parent = parent === undefined ? objs.parentNode : parent
                    } catch (error) {
                        const tempGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        tempGroup.innerHTML = queryOrMarkupOrObjs
                        objs = tempGroup.childNodes
                        for (const o of objs) {
                            tempGroup.removeChild(o)
                        }
                    }
                }
                super(parent)
                if (objs.length === 0) {
                    throw Error(`Could not interpret queryOrMarkupOrObjs '${queryOrMarkupOrObjs}' as SVG object`)
                }
                if (objs[0].parentNode && objs[0].parentNode !== this.parent) {
                    for (const o of objs) {
                        objs[0].parentNode.removeChild(o)
                        this.parent.appendChild(o)
                    }
                } else if (!objs[0].parentNode) {
                    for (const o of objs) {
                        this.parent.appendChild(o)
                    }
                }
                this.elem = objs
            }
        }
        
        function download(filename, text) {
          const element = document.createElement('a');
          element.setAttribute('href', 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(text));
          element.setAttribute('download', filename);

          element.style.display = 'none';
          document.body.appendChild(element);

          element.click();

          document.body.removeChild(element);
        }


        window.addEventListener('load', init)

        /*
        // https://stackoverflow.com/a/53953913
        // Using paper.js to perform boolean operations:

        import paper from 'paper';  
        paper.setup(new paper.Size(frameWidth, frameHeight));  

        const path1 = new paper.Path(d1);  
        const path2 = new paper.Path(d2);  

        // exclude, subtract, unite, intersect, divide  
        const result = path2.exclude(path1);  
        const svgPathElement = result.exportSVG(); // as SVGPathElement;  

        console.log(svgPathElement.outerHTML)  
        const d = svgPathElement.getAttribute('d') || '';  


          */

        
        
        // Describe your model and UI here

        let thickness = 3;
        
        const cutProps = {
            stroke: 'black',
            "stroke-width": 0.5,
            fill: 'transparent',
        }
        const engraveProps = {
            stroke: 'green',
            "stroke-width": 0.5,
            fill: 'transparent',
        }

        class Bar extends Drawable {
            constructor(x, y, width, height, parent = undefined) {
                super(parent)
                this.makeProp('x', x)
                this.makeProp('y', y)
                this.makeProp('w', width)
                this.makeProp('h', height)
                this.createRootElem('g', {
                    id: this.id
                })
                this.outline = this.createElem('path', cutProps)
                this.elem.appendChild(this.outline)
                
                this.hole1 = this.createElem('rect', this.calcHole(0))
                this.hole2 = this.createElem('rect', this.calcHole(this.w + thickness * 3))
                this.elem.appendChild(this.hole1)
                this.elem.appendChild(this.hole2)
                
                this.makeTooltip("Querstreben")
                
                this.update()
            }
            
            calcHole(dx) {
                return {
                    x: this.x - thickness * 2 + dx,
                    y: (this.y + this.h / 2) - thickness/1.5,
                    width: thickness,
                    height: thickness * 1.5,
                    ...cutProps
                }
            }
            
            withNotch() {
                this.notch = this.createElem('path', cutProps)
                return this
            }

            update() {
                let d = new PathD(this.x, this.y)
                    .hLine(this.w)
                    .vLine(this.h / 4)
                    .hLine(thickness * 1.8)
                    .halfCircle(this.h / 2)
                    .hLine(-thickness * 1.8)
                    .vLine(this.h / 4)
                    .hLine(-this.w)
                    .vLine(-this.h / 4)
                    .hLine(-thickness * 1.8)
                    .halfCircle(-this.h / 2)
                    .hLine(thickness * 1.8)
                    .close()
                this.outline.setAttribute('d', d)

                if (this.notch) {
                    // Doing this a bit clumsily to test
                    // boolean operations with primitives
                    const middle = this.x + this.w/2
                    const depth = this.h * 0.4
                    const rect1 = this.createElem('rect', {
                        x: middle + 10, y: this.y,
                        width: 5, height: depth
                    })
                    const rect2 = this.createElem('rect', {
                        x: middle + 5, y: this.y + depth/2,
                        width: 5 + 2, height: depth/2
                    })
                    const union = PathD.fromSvg(rect1).union(PathD.fromSvg(rect2))
                    this.notch.setAttribute('d', union)
                    
                    const notch2 = mirrorX(this.notch,  middle, this.y)
                    
                    const subtracted = PathD.fromSvg(this.outline).difference(PathD.fromSvg(this.notch))
                    const subtracted2 = subtracted.difference(PathD.fromSvg(notch2))
                    this.outline.setAttribute('d', subtracted2)
                }
                
                setAttribs(this.hole1, this.calcHole(0))
                setAttribs(this.hole2, this.calcHole(this.w + thickness * 3))
            }
        }
        
        class Arm extends Drawable {
            constructor(x, y, length, width, armWidth, parent = undefined) {
                super(parent)
                this.makeProp('x', x)
                this.makeProp('y', y)
                this.makeProp('l', length)
                this.makeProp('w', width)
                this.makeProp('aw', armWidth)
                this.makeProp('ro', armWidth)  // Bucket outer radius
                this.makeProp('ri', armWidth/2)  // Bucket inner radius                
                this.createRootElem('g', {id: this.id})
                this.outline = this.createElem('path', cutProps)
                this.elem.appendChild(this.outline)
                this.bucket = this.createElem('circle', {
                    cx: this.x,
                    cy: this.y + this.ro,
                    r: this.ro,
                    id: `${this.id}bucket`,
                    ...cutProps
                })
                this.hole = this.createElem('circle', {
                    cx: this.x,
                    cy: this.y + this.ro,
                    r: this.ri,
                    id: `${this.id}hole`,
                    ...cutProps
                })
                this.makeTooltip("Wurfarm des Katapults")
            }
            
            update() {
                const middle = this.x
                const notch = this.aw / 6
                const halfOutline = new PathD(middle, this.y + this.ro)
                    .hLine(this.aw/2)
                    .vLine(this.l / 2)
                    .add(`a ${notch} ${notch} 0 0 0 ${-notch} ${notch}`)
                    .vLine(notch)
                    .add(`a ${notch} ${notch} 0 0 0 ${notch} ${notch}`)
                    .hLine(notch)
                    .add(`a ${notch} ${notch} 0 0 1 ${-notch} ${notch}`)
                    .vLine(this.l /2 - 4*notch - this.aw/2)
                    .hLine(this.w/2 - this.aw/2)
                    .vLine(this.aw/4)
                    .hLine(thickness)
                    .vLine(this.aw/2)
                    .hLine(-thickness)
                    .vLine(this.aw/4)
                    .hLine(-this.w/2)
                    // todo
                    .close()
                
                // todo
                this.outline.setAttribute('d', halfOutline) // to get path svg obj
                const otherHalf = mirrorX(this.outline, middle, this.y)
                const fullOutline = halfOutline.union(PathD.fromSvg(otherHalf))
                const withOuterCircle = fullOutline.union(PathD.fromSvg(this.bucket))
                const withHole = withOuterCircle.difference(PathD.fromSvg(this.hole))
                
                this.outline.setAttribute('d', withHole)
            }
        }
        
        class Side extends Drawable {
            constructor(x, y, length, height, baseHeight, axisOffset, text, flip, parent = undefined) {
                super(parent)
                this.makeProp('x', x)
                this.makeProp('y', y)
                this.makeProp('l', length)
                this.makeProp('h', height)
                this.makeProp('bh', baseHeight)
                this.makeProp('ao', axisOffset)
                this.makeProp('text', text)
                this.makeProp('flip', flip)
                this.createRootElem('g', {id: this.id})
                this.outline = this.createElem('path', cutProps)
                this.textElem = this.createElem('text', {
                    style: `font: bold ${this.bh*0.8}px sans-serif;text-anchor:middle;fill:none;stroke:red;`
                })
                this.elem.appendChild(this.textElem)
                this.elem.appendChild(this.outline)

                if (!this.flip) this.makeTooltip("Seitenteil des Katapults")
                else this.makeTooltip("Zweites Seitenteil des Katapults (umgedreht)")
            }
            
            update() {
                const lPart = this.l / 7
                const radius = this.bh / 5
                const scaffoldHeight = this.h - this.bh
                let outline = new PathD(this.x, this.y)
                .vLine(-this.bh + radius)
                .add(`a ${radius} ${radius} 0 0 1 ${radius} ${-radius}`)
                .hLine(lPart - radius)
//                .add(`a ${radius} ${radius} 0 0 0 ${radius} ${-radius/2}`)
                .line(lPart, -scaffoldHeight)
                .hLine(lPart)
                .line(lPart, scaffoldHeight)
                .hLine(3*lPart - radius)
                .add(`a ${radius} ${radius} 0 0 1 ${radius} ${radius}`)
                .vLine(this.bh - radius)
                // todo
                .hLine(-this.l)
                
                const that = this
                function makeSlot(dx, dy) {
                    return new PathD(that.x + dx, that.y - that.bh/4*3 + dy)
                        .hLine(thickness)
                        .vLine(that.bh/2)
                        .hLine(-thickness)
                        .close()
                }
                const slot = makeSlot(lPart/4, 0)
                slot.add(makeSlot(4 * lPart, 0))
                slot.add(makeSlot(this.l - lPart/4 - thickness, 0))
                const xCenter = 2.5 * lPart
                slot.add(makeSlot(xCenter  - thickness/2, -this.h + this.bh))
                                
                outline = outline.add(slot)
                
                function makeHole(dx) {
                    return PathD.fromSvg(that.createElem('circle', {
                        cx: that.x + xCenter - thickness + that.ao + dx,
                        cy: that.y - that.bh/2 - thickness/2, // safety dist from floor
                        r: that.bh/4 + thickness/6,
                        ...cutProps
                    }))
                }
                outline = outline.add(makeHole(this.ao))
                outline = outline.add(makeHole(this.ao - that.bh/2 - 5))
                outline = outline.add(makeHole(this.ao + that.bh/2 + 5))
                
                this.outline.setAttribute('d', outline)
                resetTransform(this.outline)
                resetTransform(this.elem)

                this.textElem.innerHTML = this.text
                let textX = this.x + lPart * 2.5

                if (this.flip) {
                    textX = this.x + lPart * 4.5
                    mirrorX(this.outline, this.x + this.l/2, this.y, true)
                    rotate(this.elem, 180, this.x + this.l/2, this.y, true)
                    translate(this.elem, lPart * 2, -this.h - this.bh, true)
                }

                setAttribs(this.textElem, {
                    x: textX,
                    y: this.y - this.bh - 2
                })
            }
        }
        
        class Pins extends Drawable {
            constructor(x, y, length, parent = undefined) {
                super(parent)
                this.makeProp('x', x)
                this.makeProp('y', y)
                this.makeProp('l', length)
                this.createRootElem('g', {})
                this.path = this.createElem('path', cutProps)
                this.elem.appendChild(this.path)
                this.makeTooltip("Keile zum Zusammenstecken")
            }
            
            update() {
                const numBlocks = 6  // each block is two pins
                const minWidth = thickness
                const maxWidth = thickness*2
                const path = new PathD(this.x, this.y)
                path.hLine(numBlocks * (maxWidth + minWidth))
                    .vLine(this.l)
                    .hLine(-numBlocks * (maxWidth + minWidth))
                    .close()
                for (let i=0; i<numBlocks; i++) {
                    path.move(minWidth, 0)
                        .line(maxWidth-minWidth, this.l)
                        .move(minWidth, 0)
                        .vLine(-this.l)
                }
                this.path.setAttribute('d', path)
            }
        }

        function init() {
            // Init is called automatically when page is loaded

            function updateThickness(evt) {
                thickness = Number(evt.target.value)
                Drawable.update()
            }
            document.querySelector('#dicke').addEventListener('input', updateThickness)
            updateThickness({target: document.querySelector('#dicke')})
            
            const rippenLaenge = 60
            const rippenHoehe = 20
            const armLaenge = 130
            const katapultLaenge = 250
            const achsenOffset = 0

            const pins = new Pins(20, 10, rippenHoehe, svg)
            pins.update()

            const barNotch = new Bar(20, 10 + rippenHoehe, rippenLaenge, rippenHoehe).withNotch()
            barNotch.bind('w', '#breite')

            for (let i=2; i<5; i++) {
                const bar = new Bar(20, 10 + rippenHoehe * i, rippenLaenge, rippenHoehe, svg)
                bar.bind('w', '#breite')
            }

            const arm = new Arm(300, 10, armLaenge, rippenLaenge, rippenHoehe)
            arm.bind('w', '#breite')
            arm.bind('l', '#armLaenge')
            
            const seite = new Side(10, 330, katapultLaenge, armLaenge/2 + 1.5*rippenHoehe, rippenHoehe, achsenOffset, "", false)
            seite.bind('ao', '#achse')
            seite.bind('l', '#laenge')
            seite.bind('text', '#name')
            seite.bind(_ => {
                seite.h = arm.l/2 + 1.5*seite.bh
                seite.update()
            }, arm, 'l')
            
            let seite2 = undefined
            function MachSeite2() {
                if (!seite2) {  // Nur 1x erstellen
                    seite2 = new Side(10, 330, katapultLaenge, armLaenge/2 + 1.5*rippenHoehe, rippenHoehe, achsenOffset, "", true)
                    seite2.bind('ao', '#achse')
                    seite2.bind('l', '#laenge')
                    seite2.bind('text', '#name')
                    seite2.bind(_ => {
                        seite2.h = arm.l/2 + 1.5*seite2.bh
                        seite2.update()
                    }, arm, 'l')
                }
            }
            
            document.querySelector('#download').addEventListener('click', evt => {
                MachSeite2()
                PathD._ensurePaperReady()
                paper.project.activeLayer.importSVG(svg, {insert: true})
                const name = document.querySelector('#name').value
                download(`Katapult ${name}.svg`, paper.project.activeLayer.exportSVG({asString:true}))
            })

            function portraitCheck() {
                window.setTimeout(_ => {
                    const elem = document.getElementById('note')
                    if (window.matchMedia("(orientation: portrait)").matches) {
                        elem.textContent = "(Bitte Telefon auf die Seite drehen)"
                    }
                    else {
                        elem.textContent = ""
                    }
                }, 200)
            }
            window.addEventListener("orientationchange", _ => {
                portraitCheck()
            })
            portraitCheck()

            document.querySelector('#qrcode').addEventListener('click', evt => {
                let url = ''  // `https://schuderer.net/katapult/#`
                const ctls = document.querySelectorAll('#controls input')
                for (const input of ctls) {
                    const val = input.value.replace('~', '-')
                    url += `${encodeURIComponent(val)}~`
                }
                url = url.slice(0, -1)  // remove last separator
                console.log(url)
                const overlay = document.querySelector('#overlay')
                overlay.style.display = 'block'
                while (overlay.firstChild) overlay.removeChild(overlay.firstChild)
                const overlayDim = Math.min(overlay.offsetWidth, overlay.offsetHeight, 512)
                new QRCode(overlay, {
                    text: url,
                    useSVG: true,
                });
                const qrcode = overlay.querySelector('svg')
                qrcode.width = overlayDim
                qrcode.height = overlayDim
//                new QRCode(overlay, {
//                    text: url,
//                    width: '100%',
//                    height: '100%',
//                    colorDark : "#000000",
//                    colorLight : "#ffffff",
//                    correctLevel : QRCode.CorrectLevel.H
//                })
                function dismiss() {
                    overlay.style.display = 'none'
                    overlay.removeEventListener('click', dismiss)
                    document.body.removeEventListener('click', dismiss)
                }
                overlay.addEventListener('click', dismiss)
                document.body.addEventListener('keyup', dismiss)
            })
            
            function setParamsFromString(paramStr) {
                params = paramStr.split("~")
                const ctls = document.querySelectorAll('#controls input')
                if (params.length !== ctls.length) {
                    console.error(`Version mismatch: ${ctls.length} controls vs. ${params.length} params`)
                }
                let i = 0
                for (const input of ctls) {
                    const val = decodeURIComponent(params[i])
                    input.value = val
                    input.dispatchEvent(new Event('input'));
                    i++
                }
            }

            if (QrScanner.hasCamera()) {
                let qrScanner = undefined
                const button = document.querySelector('#scan')
                button.style.display = "inline-block"
                button.addEventListener('click', evt => {
                    // https://github.com/nimiq/qr-scanner
                    const videoElem = document.querySelector('#video')
                    function dismiss() {
                        videoElem.style.display = 'none'
                        videoElem.removeEventListener('click', dismiss)
                        document.body.removeEventListener('click', dismiss)
                        qrScanner.stop()
                    }
                    if (!qrScanner) {
                        qrScanner = new QrScanner(
                            videoElem,
                            result => {
                                console.log('decoded qr code:', result)
                                setParamsFromString(result.data)
                                dismiss()
                            },
                            {
                                maxScansPerSecond: 4,
                                highlightScanRegion: true,
                                highlightCodeOutline: true,
                                returnDetailedScanResult: true,
                                onDecodeError: err => {
                                    console.log(`Error: ${err}`)
                                }
                            },
                        )
                    }
                    videoElem.style.display = 'block'
                    qrScanner.start()
                    videoElem.addEventListener('click', dismiss)
                    document.body.addEventListener('keyup', dismiss)
                })
            }


            
            // Some binding and other tests
                //            const c = new Bar(10, 50, 60, 20, svg)
                //            c.bind(_ => {
                //                c.w = b.w / 2;
                //                c.update()
                //            }, b, 'w')
                //            c.update()
                //            const p = new SvgProxy('#g5087')
                //            const p2 = new SvgProxy(' <circle cx="25" cy="75" r="20" stroke="red" fill="transparent" stroke-width="5"/>')
                //            const circ = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                //            circ.setAttribute('cx', 150)
                //            circ.setAttribute('cy', 150)
                //            circ.setAttribute('r', 50)
                //            const circle = new SvgProxy(circ)
                //            console.log(circle.elem[0])
                //            console.log(circle.parent)
                //                //p.elem[0].setAttribute('transform', 'rotate(45)')
        }
    </script>
</body>

</html>